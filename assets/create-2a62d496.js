import{d as F,h as I}from"./index-49ca2576.js";function de(e,n){let{target:t}=e;for(;t;){if(t.dataset&&t.dataset[n]!==void 0)return!0;t=t.parentElement}return!1}const ce=F({name:"ChevronRight",render(){return I("svg",{viewBox:"0 0 16 16",fill:"none",xmlns:"http://www.w3.org/2000/svg"},I("path",{d:"M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",fill:"currentColor"}))}});function _(e){return Array.isArray(e)?e:[e]}const G={STOP:"STOP"};function R(e,n){const t=n(e);e.children!==void 0&&t!==G.STOP&&e.children.forEach(r=>R(r,n))}function j(e,n={}){const{preserveGroup:t=!1}=n,r=[],s=t?i=>{i.isLeaf||(r.push(i.key),u(i.children))}:i=>{i.isLeaf||(i.isGroup||r.push(i.key),u(i.children))};function u(i){i.forEach(s)}return u(e),r}function U(e,n){const{isLeaf:t}=e;return t!==void 0?t:!n(e)}function Z(e){return e.children}function q(e){return e.key}function B(){return!1}function V(e,n){const{isLeaf:t}=e;return!(t===!1&&!Array.isArray(n(e)))}function W(e){return e.disabled===!0}function z(e,n){return e.isLeaf===!1&&!Array.isArray(n(e))}function x(e){var n;return e==null?[]:Array.isArray(e)?e:(n=e.checkedKeys)!==null&&n!==void 0?n:[]}function P(e){var n;return e==null||Array.isArray(e)?[]:(n=e.indeterminateKeys)!==null&&n!==void 0?n:[]}function H(e,n){const t=new Set(e);return n.forEach(r=>{t.has(r)||t.add(r)}),Array.from(t)}function J(e,n){const t=new Set(e);return n.forEach(r=>{t.has(r)&&t.delete(r)}),Array.from(t)}function Q(e){return(e==null?void 0:e.type)==="group"}function fe(e){const n=new Map;return e.forEach((t,r)=>{n.set(t.key,r)}),t=>{var r;return(r=n.get(t))!==null&&r!==void 0?r:null}}class X extends Error{constructor(){super(),this.message="SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded."}}function Y(e,n,t,r){return A(n.concat(e),t,r,!1)}function $(e,n){const t=new Set;return e.forEach(r=>{const s=n.treeNodeMap.get(r);if(s!==void 0){let u=s.parent;for(;u!==null&&!(u.disabled||t.has(u.key));)t.add(u.key),u=u.parent}}),t}function ee(e,n,t,r){const s=A(n,t,r,!1),u=A(e,t,r,!0),i=$(e,t),c=[];return s.forEach(f=>{(u.has(f)||i.has(f))&&c.push(f)}),c.forEach(f=>s.delete(f)),s}function E(e,n){const{checkedKeys:t,keysToCheck:r,keysToUncheck:s,indeterminateKeys:u,cascade:i,leafOnly:c,checkStrategy:f,allowNotLoaded:o}=e;if(!i)return r!==void 0?{checkedKeys:H(t,r),indeterminateKeys:Array.from(u)}:s!==void 0?{checkedKeys:J(t,s),indeterminateKeys:Array.from(u)}:{checkedKeys:Array.from(t),indeterminateKeys:Array.from(u)};const{levelTreeNodeMap:h}=n;let d;s!==void 0?d=ee(s,t,n,o):r!==void 0?d=Y(r,t,n,o):d=A(t,n,o,!1);const v=f==="parent",b=f==="child"||c,g=d,S=new Set,N=Math.max.apply(null,Array.from(h.keys()));for(let K=N;K>=0;K-=1){const L=K===0,w=h.get(K);for(const a of w){if(a.isLeaf)continue;const{key:l,shallowLoaded:p}=a;if(b&&p&&a.children.forEach(y=>{!y.disabled&&!y.isLeaf&&y.shallowLoaded&&g.has(y.key)&&g.delete(y.key)}),a.disabled||!p)continue;let m=!0,k=!1,C=!0;for(const y of a.children){const O=y.key;if(!y.disabled){if(C&&(C=!1),g.has(O))k=!0;else if(S.has(O)){k=!0,m=!1;break}else if(m=!1,k)break}}m&&!C?(v&&a.children.forEach(y=>{!y.disabled&&g.has(y.key)&&g.delete(y.key)}),g.add(l)):k&&S.add(l),L&&b&&g.has(l)&&g.delete(l)}}return{checkedKeys:Array.from(g),indeterminateKeys:Array.from(S)}}function A(e,n,t,r){const{treeNodeMap:s,getChildren:u}=n,i=new Set,c=new Set(e);return e.forEach(f=>{const o=s.get(f);o!==void 0&&R(o,h=>{if(h.disabled)return G.STOP;const{key:d}=h;if(!i.has(d)&&(i.add(d),c.add(d),z(h.rawNode,u))){if(r)return G.STOP;if(!t)throw new X}})}),c}function te(e,{includeGroup:n=!1,includeSelf:t=!0},r){var s;const u=r.treeNodeMap;let i=e==null?null:(s=u.get(e))!==null&&s!==void 0?s:null;const c={keyPath:[],treeNodePath:[],treeNode:i};if(i!=null&&i.ignored)return c.treeNode=null,c;for(;i;)!i.ignored&&(n||!i.isGroup)&&c.treeNodePath.push(i),i=i.parent;return c.treeNodePath.reverse(),t||c.treeNodePath.pop(),c.keyPath=c.treeNodePath.map(f=>f.key),c}function ne(e){if(e.length===0)return null;const n=e[0];return n.isGroup||n.ignored||n.disabled?n.getNext():n}function re(e,n){const t=e.siblings,r=t.length,{index:s}=e;return n?t[(s+1)%r]:s===t.length-1?null:t[s+1]}function M(e,n,{loop:t=!1,includeDisabled:r=!1}={}){const s=n==="prev"?ie:re,u={reverse:n==="prev"};let i=!1,c=null;function f(o){if(o!==null){if(o===e){if(!i)i=!0;else if(!e.disabled&&!e.isGroup){c=e;return}}else if((!o.disabled||r)&&!o.ignored&&!o.isGroup){c=o;return}if(o.isGroup){const h=T(o,u);h!==null?c=h:f(s(o,t))}else{const h=s(o,!1);if(h!==null)f(h);else{const d=se(o);d!=null&&d.isGroup?f(s(d,t)):t&&f(s(o,!0))}}}}return f(e),c}function ie(e,n){const t=e.siblings,r=t.length,{index:s}=e;return n?t[(s-1+r)%r]:s===0?null:t[s-1]}function se(e){return e.parent}function T(e,n={}){const{reverse:t=!1}=n,{children:r}=e;if(r){const{length:s}=r,u=t?s-1:0,i=t?-1:s,c=t?-1:1;for(let f=u;f!==i;f+=c){const o=r[f];if(!o.disabled&&!o.ignored)if(o.isGroup){const h=T(o,n);if(h!==null)return h}else return o}}return null}const ae={getChild(){return this.ignored?null:T(this)},getParent(){const{parent:e}=this;return e!=null&&e.isGroup?e.getParent():e},getNext(e={}){return M(this,"next",e)},getPrev(e={}){return M(this,"prev",e)}};function le(e,n){const t=n?new Set(n):void 0,r=[];function s(u){u.forEach(i=>{r.push(i),!(i.isLeaf||!i.children||i.ignored)&&(i.isGroup||t===void 0||t.has(i.key))&&s(i.children)})}return s(e),r}function oe(e,n){const t=e.key;for(;n;){if(n.key===t)return!0;n=n.parent}return!1}function D(e,n,t,r,s,u=null,i=0){const c=[];return e.forEach((f,o)=>{var h;const d=Object.create(r);if(d.rawNode=f,d.siblings=c,d.level=i,d.index=o,d.isFirstChild=o===0,d.isLastChild=o+1===e.length,d.parent=u,!d.ignored){const v=s(f);Array.isArray(v)&&(d.children=D(v,n,t,r,s,d,i+1))}c.push(d),n.set(d.key,d),t.has(i)||t.set(i,[]),(h=t.get(i))===null||h===void 0||h.push(d)}),c}function he(e,n={}){var t;const r=new Map,s=new Map,{getDisabled:u=W,getIgnored:i=B,getIsGroup:c=Q,getKey:f=q}=n,o=(t=n.getChildren)!==null&&t!==void 0?t:Z,h=n.ignoreEmptyChildren?a=>{const l=o(a);return Array.isArray(l)?l.length?l:null:l}:o,d=Object.assign({get key(){return f(this.rawNode)},get disabled(){return u(this.rawNode)},get isGroup(){return c(this.rawNode)},get isLeaf(){return U(this.rawNode,h)},get shallowLoaded(){return V(this.rawNode,h)},get ignored(){return i(this.rawNode)},contains(a){return oe(this,a)}},ae),v=D(e,r,s,d,h);function b(a){if(a==null)return null;const l=r.get(a);return l&&!l.isGroup&&!l.ignored?l:null}function g(a){if(a==null)return null;const l=r.get(a);return l&&!l.ignored?l:null}function S(a,l){const p=g(a);return p?p.getPrev(l):null}function N(a,l){const p=g(a);return p?p.getNext(l):null}function K(a){const l=g(a);return l?l.getParent():null}function L(a){const l=g(a);return l?l.getChild():null}const w={treeNodes:v,treeNodeMap:r,levelTreeNodeMap:s,maxLevel:Math.max(...s.keys()),getChildren:h,getFlattenedNodes(a){return le(v,a)},getNode:b,getPrev:S,getNext:N,getParent:K,getChild:L,getFirstAvailableNode(){return ne(v)},getPath(a,l={}){return te(a,l,w)},getCheckedKeys(a,l={}){const{cascade:p=!0,leafOnly:m=!1,checkStrategy:k="all",allowNotLoaded:C=!1}=l;return E({checkedKeys:x(a),indeterminateKeys:P(a),cascade:p,leafOnly:m,checkStrategy:k,allowNotLoaded:C},w)},check(a,l,p={}){const{cascade:m=!0,leafOnly:k=!1,checkStrategy:C="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:x(l),indeterminateKeys:P(l),keysToCheck:a==null?[]:_(a),cascade:m,leafOnly:k,checkStrategy:C,allowNotLoaded:y},w)},uncheck(a,l,p={}){const{cascade:m=!0,leafOnly:k=!1,checkStrategy:C="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:x(l),indeterminateKeys:P(l),keysToUncheck:a==null?[]:_(a),cascade:m,leafOnly:k,checkStrategy:C,allowNotLoaded:y},w)},getNonLeafKeys(a={}){return j(v,a)}};return w}export{ce as C,he as a,fe as c,de as h};
