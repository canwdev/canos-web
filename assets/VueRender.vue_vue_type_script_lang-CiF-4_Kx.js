import{d as e,B as n}from"./index-DSBX7T2Q.js";function r(e,n){let{target:r}=e;for(;r;){if(r.dataset&&void 0!==r.dataset[n])return!0;r=r.parentElement}return!1}const t=e({name:"ChevronRight",render:()=>n("svg",{viewBox:"0 0 16 16",fill:"none",xmlns:"http://www.w3.org/2000/svg"},n("path",{d:"M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",fill:"currentColor"}))});function o(e){return Array.isArray(e)?e:[e]}const i={STOP:"STOP"};function s(e,n){const r=n(e);void 0!==e.children&&r!==i.STOP&&e.children.forEach((e=>s(e,n)))}function a(e){return e.children}function l(e){return e.key}function c(){return!1}function d(e){return!0===e.disabled}function u(e){var n;return null==e?[]:Array.isArray(e)?e:null!==(n=e.checkedKeys)&&void 0!==n?n:[]}function f(e){var n;return null==e||Array.isArray(e)?[]:null!==(n=e.indeterminateKeys)&&void 0!==n?n:[]}function h(e,n){const r=new Set(e);return n.forEach((e=>{r.has(e)||r.add(e)})),Array.from(r)}function y(e,n){const r=new Set(e);return n.forEach((e=>{r.has(e)&&r.delete(e)})),Array.from(r)}function g(e){return"group"===(null==e?void 0:e.type)}function p(e){const n=new Map;return e.forEach(((e,r)=>{n.set(e.key,r)})),e=>{var r;return null!==(r=n.get(e))&&void 0!==r?r:null}}class k extends Error{constructor(){super(),this.message="SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded."}}function v(e,n,r,t){const o=w(n,r,t,!1),i=w(e,r,t,!0),s=function(e,n){const r=new Set;return e.forEach((e=>{const t=n.treeNodeMap.get(e);if(void 0!==t){let e=t.parent;for(;null!==e&&!e.disabled&&!r.has(e.key);)r.add(e.key),e=e.parent}})),r}(e,r),a=[];return o.forEach((e=>{(i.has(e)||s.has(e))&&a.push(e)})),a.forEach((e=>o.delete(e))),o}function N(e,n){const{checkedKeys:r,keysToCheck:t,keysToUncheck:o,indeterminateKeys:i,cascade:s,leafOnly:a,checkStrategy:l,allowNotLoaded:c}=e;if(!s)return void 0!==t?{checkedKeys:h(r,t),indeterminateKeys:Array.from(i)}:void 0!==o?{checkedKeys:y(r,o),indeterminateKeys:Array.from(i)}:{checkedKeys:Array.from(r),indeterminateKeys:Array.from(i)};const{levelTreeNodeMap:d}=n;let u;u=void 0!==o?v(o,r,n,c):void 0!==t?function(e,n,r,t){return w(n.concat(e),r,t,!1)}(t,r,n,c):w(r,n,c,!1);const f="parent"===l,g="child"===l||a,p=u,k=new Set;for(let h=Math.max.apply(null,Array.from(d.keys()));h>=0;h-=1){const e=0===h,n=d.get(h);for(const r of n){if(r.isLeaf)continue;const{key:n,shallowLoaded:t}=r;if(g&&t&&r.children.forEach((e=>{!e.disabled&&!e.isLeaf&&e.shallowLoaded&&p.has(e.key)&&p.delete(e.key)})),r.disabled||!t)continue;let o=!0,i=!1,s=!0;for(const e of r.children){const n=e.key;if(!e.disabled)if(s&&(s=!1),p.has(n))i=!0;else{if(k.has(n)){i=!0,o=!1;break}if(o=!1,i)break}}o&&!s?(f&&r.children.forEach((e=>{!e.disabled&&p.has(e.key)&&p.delete(e.key)})),p.add(n)):i&&k.add(n),e&&g&&p.has(n)&&p.delete(n)}}return{checkedKeys:Array.from(p),indeterminateKeys:Array.from(k)}}function w(e,n,r,t){const{treeNodeMap:o,getChildren:a}=n,l=new Set,c=new Set(e);return e.forEach((e=>{const n=o.get(e);void 0!==n&&s(n,(e=>{if(e.disabled)return i.STOP;const{key:n}=e;if(!l.has(n)&&(l.add(n),c.add(n),function(e,n){return!1===e.isLeaf&&!Array.isArray(n(e))}(e.rawNode,a))){if(t)return i.STOP;if(!r)throw new k}}))})),c}function m(e,n){const r=e.siblings,t=r.length,{index:o}=e;return n?r[(o+1)%t]:o===r.length-1?null:r[o+1]}function L(e,n,{loop:r=!1,includeDisabled:t=!1}={}){const o="prev"===n?b:m,i={reverse:"prev"===n};let s=!1,a=null;return function n(l){if(null!==l){if(l===e)if(s){if(!e.disabled&&!e.isGroup)return void(a=e)}else s=!0;else if((!l.disabled||t)&&!l.ignored&&!l.isGroup)return void(a=l);if(l.isGroup){const e=A(l,i);null!==e?a=e:n(o(l,r))}else{const e=o(l,!1);if(null!==e)n(e);else{const e=function(e){return e.parent}(l);(null==e?void 0:e.isGroup)?n(o(e,r)):r&&n(o(l,!0))}}}}(e),a}function b(e,n){const r=e.siblings,t=r.length,{index:o}=e;return n?r[(o-1+t)%t]:0===o?null:r[o-1]}function A(e,n={}){const{reverse:r=!1}=n,{children:t}=e;if(t){const{length:e}=t,o=r?-1:e,i=r?-1:1;for(let s=r?e-1:0;s!==o;s+=i){const e=t[s];if(!e.disabled&&!e.ignored){if(!e.isGroup)return e;{const r=A(e,n);if(null!==r)return r}}}}return null}const K={getChild(){return this.ignored?null:A(this)},getParent(){const{parent:e}=this;return(null==e?void 0:e.isGroup)?e.getParent():e},getNext(e={}){return L(this,"next",e)},getPrev(e={}){return L(this,"prev",e)}};function S(e,n,r,t,o,i=null,s=0){const a=[];return e.forEach(((l,c)=>{var d;const u=Object.create(t);if(u.rawNode=l,u.siblings=a,u.level=s,u.index=c,u.isFirstChild=0===c,u.isLastChild=c+1===e.length,u.parent=i,!u.ignored){const e=o(l);Array.isArray(e)&&(u.children=S(e,n,r,t,o,u,s+1))}a.push(u),n.set(u.key,u),r.has(s)||r.set(s,[]),null===(d=r.get(s))||void 0===d||d.push(u)})),a}function C(e,n={}){var r;const t=new Map,i=new Map,{getDisabled:s=d,getIgnored:h=c,getIsGroup:y=g,getKey:p=l}=n,k=null!==(r=n.getChildren)&&void 0!==r?r:a,v=n.ignoreEmptyChildren?e=>{const n=k(e);return Array.isArray(n)?n.length?n:null:n}:k,w=Object.assign({get key(){return p(this.rawNode)},get disabled(){return s(this.rawNode)},get isGroup(){return y(this.rawNode)},get isLeaf(){return function(e,n){const{isLeaf:r}=e;return void 0!==r?r:!n(e)}(this.rawNode,v)},get shallowLoaded(){return function(e,n){const{isLeaf:r}=e;return!(!1===r&&!Array.isArray(n(e)))}(this.rawNode,v)},get ignored(){return h(this.rawNode)},contains(e){return function(e,n){const r=e.key;for(;n;){if(n.key===r)return!0;n=n.parent}return!1}(this,e)}},K),m=S(e,t,i,w,v);function L(e){if(null==e)return null;const n=t.get(e);return n&&!n.ignored?n:null}const b={treeNodes:m,treeNodeMap:t,levelTreeNodeMap:i,maxLevel:Math.max(...i.keys()),getChildren:v,getFlattenedNodes:e=>function(e,n){const r=n?new Set(n):void 0,t=[];return function e(n){n.forEach((n=>{t.push(n),n.isLeaf||!n.children||n.ignored||(n.isGroup||void 0===r||r.has(n.key))&&e(n.children)}))}(e),t}(m,e),getNode:function(e){if(null==e)return null;const n=t.get(e);return!n||n.isGroup||n.ignored?null:n},getPrev:function(e,n){const r=L(e);return r?r.getPrev(n):null},getNext:function(e,n){const r=L(e);return r?r.getNext(n):null},getParent:function(e){const n=L(e);return n?n.getParent():null},getChild:function(e){const n=L(e);return n?n.getChild():null},getFirstAvailableNode:()=>function(e){if(0===e.length)return null;const n=e[0];return n.isGroup||n.ignored||n.disabled?n.getNext():n}(m),getPath:(e,n={})=>function(e,{includeGroup:n=!1,includeSelf:r=!0},t){var o;const i=t.treeNodeMap;let s=null==e?null:null!==(o=i.get(e))&&void 0!==o?o:null;const a={keyPath:[],treeNodePath:[],treeNode:s};if(null==s?void 0:s.ignored)return a.treeNode=null,a;for(;s;)s.ignored||!n&&s.isGroup||a.treeNodePath.push(s),s=s.parent;return a.treeNodePath.reverse(),r||a.treeNodePath.pop(),a.keyPath=a.treeNodePath.map((e=>e.key)),a}(e,n,b),getCheckedKeys(e,n={}){const{cascade:r=!0,leafOnly:t=!1,checkStrategy:o="all",allowNotLoaded:i=!1}=n;return N({checkedKeys:u(e),indeterminateKeys:f(e),cascade:r,leafOnly:t,checkStrategy:o,allowNotLoaded:i},b)},check(e,n,r={}){const{cascade:t=!0,leafOnly:i=!1,checkStrategy:s="all",allowNotLoaded:a=!1}=r;return N({checkedKeys:u(n),indeterminateKeys:f(n),keysToCheck:null==e?[]:o(e),cascade:t,leafOnly:i,checkStrategy:s,allowNotLoaded:a},b)},uncheck(e,n,r={}){const{cascade:t=!0,leafOnly:i=!1,checkStrategy:s="all",allowNotLoaded:a=!1}=r;return N({checkedKeys:u(n),indeterminateKeys:f(n),keysToUncheck:null==e?[]:o(e),cascade:t,leafOnly:i,checkStrategy:s,allowNotLoaded:a},b)},getNonLeafKeys:(e={})=>function(e,n={}){const{preserveGroup:r=!1}=n,t=[],o=r?e=>{e.isLeaf||(t.push(e.key),i(e.children))}:e=>{e.isLeaf||(e.isGroup||t.push(e.key),i(e.children))};function i(e){e.forEach(o)}return i(e),t}(m,e)};return b}const P=e({name:"VueRender",props:{renderFn:{type:[Object,Function],required:!0}},render(){return"function"==typeof this.renderFn?this.renderFn():this.renderFn}});export{t as C,P as _,C as a,p as c,r as h};
